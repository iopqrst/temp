<!DOCTYPE HTML>
<html lang="en-US">
<head>
	<meta charset="UTF-8">
	<title></title>
	<style type="text/css">
		#div1 {
			height:200px;
			border:1px solid green;
			width:250px;
		}
		
		#div2 {
			height:160px;
			background:red;
			width:200px;
		}
		
		#div3 {
			height:120px;
			background:green;
			width:150px;
		}
		
		#div4 {
			height:80px;
			background:blue;
			width:100px;
		}
	</style>
</head>
<body>
	<input type="button" id="btn" value="click me!!"/>
	
	
	<div id="div1">
	  <div id="div2">
		<div id="div3">
		  <div id="div4">
		  </div>
		</div>
	  </div>
	</div>
	
</body>

<script type="text/javascript">
		/**
		 *
		 * 参考文章： http://www.cnblogs.com/frostbelt/archive/2012/03/11/2390244.html
		 *
		 * obj.addEventListener(event, fn, useCapture)
		 * obj 文档节点、document、window或XMLHttpRequest
		 * event 事件名称 不含‘on',比如“click"、”mouseover"、“keydown"等
		 * fn 实现监听的接口或函数
		 * useCapture 是否使用捕获，一般为false
		 * 
		 * 事件流：
		 *
		 * 事件发生时候分为3个阶段：
		 * <b> 捕获阶段： </b> 从根节点开始顺序而下，检测每个节点是否注册了事件处理程序。如果注册了事件处理程序，并且useCapture为true,则调用改时间处理程序。（ie中无此阶段）
		 * <b> 目标阶段： </b> 触发在目标对象本身注册的事件处理程序，也称正常事件派发阶段。
		 * <b> 冒泡阶段： </b> 从目标节点到根节点，检测每个节点是否注册了事件处理程序，如果注册了事件处理程序，并且 useCapture 为 false，则调用该事件处理程序。
		 *
		 *
		 * 结论（包含捕获与冒泡）：
		 * true 的触发顺序总是在 false 之前；
		 * 如果多个均为 true，则外层的触发先于内层；
		 * 如果多个均为 false，则内层的触发先于外层。
		 */
		function bindEvent(obj, fn, event) {
			
			if(obj.attachEvent) {
				obj.attachEvent('on'+event, function(){
					fn.call(obj);
				});
			} else {
				obj.addEventListener(event, fn, false);
			}
		}
		
		/**
		// 执行顺序没有搞定
		var oBtn = document.getElementById('btn');
		
		bindEvent(oBtn, function(){
			alert(1);
		}, 'click');
		
		bindEvent(oBtn, function(){
			alert(2);
		}, 'click');
		
		bindEvent(oBtn, function(){
			alert(3);
		}, 'click');
		*/
	</script>
</html>