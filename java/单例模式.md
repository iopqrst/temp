# Java 单例模式 

Java中单例(Singleton)模式是一种广泛使用的设计模式。单例模式的主要作用是保证在Java程序中，某个类只有一个实例存在。一些管理器和控制器常被设计成单例模式。

单例模式有很多好处，它能够避免实例对象的重复创建，不仅可以减少每次创建对象的时间开销，还可以节约内存空间；能够避免由于操作多个实例导致的逻辑错误。如果有一个对象有可能贯穿整个应用程序，而且起到了全局统一管理控制的作用，那么单例模式也许是一个值得考虑的选择。

## 1、饿汉模式

```java

public class Singleton{  

    private static Singleton instance = new Singleton(); 

    private Singleton(){}  

    public static Singleton newInstance(){  
        return instance;  
    }  

}

```

> 从代码中我们看到，类的构造函数定义为private的，保证其他类不能实例化此类，然后提供了一个静态实例并返回给调用者。饿汉模式是最简单的一种实现方式，饿汉模式在类加载的时候就会对实例进行创建，实例在整个程序周期都存在。它的好处只在类加载的时候创建一个实例，不会存在多个线程创建多个实例的情况，避免了多个线程同步的问题。它的缺点也很明显，即使这个单例没有用到也会被创建，而且在类加载之后就会被创建，内存就被浪费了。
>
> 这种实现方式适合单例占用内存比较小，在初始化时就会被用到的情况。但是，如果单例占用的内存比较大或单例只是在某个特定场景下才会用到，使用饿汉模式就不适合了，这时候需要用到懒汉模式进行延迟加载。

## 2、懒汉模式

``` java

public class Singleton{  
    private static Singleton instance = null;

    private Singleton(){}  

    public static Singleton newInstance(){  
        if(null == instance){  
            instance = new Singleton();  
        }  
        return instance;  
    }

} 

```

> 懒汉模式中单例是在需要的时候才去创建，如果单例已经创建，再次调用获取接口将不会重新创建新的对象，而是直接返回之前创建的对象。如果某个单例使用的次数少，并且创建单例消耗的资源较多，那么就需要实现单例的按需创建，这个时候使用懒汉模式就是一个不错的选择。但是这里的懒汉模式并没有考虑线程安全的问题，多个线程并发时可能同时调用getInstance()方法，导致创建多个实例，因此需要枷锁解决线程同步问题，如下：

``` java

public class Singleton{  
    private static Singleton instance = null;

    private Singleton(){}  

    public static synchronized Singleton newInstance(){  
        if(null == instance){  
            instance = new Singleton();  
        }  
        return instance;  
    }  

}

```

## 3、双重校验锁

加锁的懒汉模式看起来解决了线程并发的问题，又实现了延迟加载，然而它存在性能问题，依然不够完美。synchronized 修饰的同步方法比一般方法要慢很多，如果多次调用getInstance(), 累积的性能损耗就比较大。因此就有了双重校验锁。


``` java

public class Singleton {  
    private static Singleton instance = null;  
    private Singleton(){}  
    public static Singleton getInstance() {  
        if (instance == null) {  
            synchronized (Singleton.class) {  
                if (instance == null) {//2  
                    instance = new Singleton();  
                }  
            }  
        }  
        return instance;  
    }  
}

```

可以看到上面在同步代码块外多了一层instance为空的判断。由于单例对象只需要创建一次，如果后面再次调用getInstance() 只需要直接返回单例对象。因此，因此，大部分情况下，调用getInstance()都不会执行到同步代码块，从而提高了程序性能。不过还需要考虑一种情况，假如两个线程A、B，A执行了·`if (instance == null)`语句，它会认为单例对象没有创建，此时线程切到B也执行了同样的语句，B也认为单例对象没有创建，然后两个线程依次执行同步代码块，并分别创建了一个单例对象。为了解决这个问题，还需要在同步代码块中增加`if (instance == null)`语句，也就是上面看到的代码2。

我们看到双重校验锁即实现了延迟加载，又解决了线程并发问题，同时还解决了执行效率问题，是否真的就万无一失了呢？

这里要提到Java中的指令重排优化。所谓<b>指令重排优化</b>是指在不改变原语义的情况下，通过调整指令的执行顺序让程序运行的更快。JVM中并没有规定编译器优化相关的内容，也就是说JVM可以自由的进行指令重排序的优化。

这个问题的关键就在于由于指令重排优化的存在，导致初始化Singleton和将对象地址赋给instance字段的顺序是不确定的。在某个线程创建单例对象时，在构造方法被调用之前，就为该对象分配了内存空间并将对象的字段设置为默认值。此时就可以将分配的内存地址赋值给instance字段了，然而该对象可能还没有初始化。若紧接着另外一个线程来调用getInstance，取到的就是状态不正确的对象，程序就会出错。

以上就是双重校验锁会失效的原因，不过还好在JDK1.5及之后版本增加了volatile关键字。volatile的一个语义是禁止指令重排序优化，也就保证了instance变量被赋值的时候对象已经是初始化过的，从而避免了上面说到的问题。代码如下：

``` java

public class Singleton {  
    private static volatile Singleton instance = null;  // volatile

    private Singleton(){}  

    public static Singleton getInstance() {  
        if (instance == null) {  
            synchronized (Singleton.class) {  
                if (instance == null) {  
                    instance = new Singleton();  
                }  
            }  
        }  
        return instance;  

    }  
} 


```

## 4、静态内部类


``` java

public class Singleton{  
    private static class SingletonHolder{  
        public static Singleton instance = new Singleton();  
    }

    private Singleton(){}  

    public static Singleton newInstance(){  
        return SingletonHolder.instance;  
    }  
}

```

> 这种方式同样利用了类加载机制来保证只创建一个instance实例。它与饿汉模式一样，也是利用了类加载机制，因此不存在多线程并发的问题。不一样的是，它是在内部类里面去创建对象实例。这样的话，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。


## 5、枚举

``` java

public enum Singleton {

    instance;
    public void whateverMethod() {}

}

```

> 上面提到的四种实现单例的方式都有共同的缺点：

> 1. 需要额外的工作来实现序列化，否则每次反序列化的兑现时都会创建一个新的实例。
> 2. 可以使用反射强行调用私有构造器（如果要避免这种情况，可以修改构造器，让它在创建第二个实例的时候抛异常）。